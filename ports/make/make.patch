diff -Paur --no-dereference -- make.upstream/src/dir.c make/src/dir.c
--- make.upstream/src/dir.c
+++ make/src/dir.c
@@ -20,6 +20,8 @@
 #include "dep.h"
 #include "debug.h"
 
+#include <stddef.h>
+
 #ifdef  HAVE_DIRENT_H
 # include <dirent.h>
 # define NAMLEN(dirent) strlen((dirent)->d_name)
@@ -1253,7 +1255,7 @@
           /* The glob interface wants a 'struct dirent', so mock one up.  */
           struct dirent *d;
           size_t len = df->length + 1;
-          size_t sz = sizeof (*d) - sizeof (d->d_name) + len;
+          size_t sz = offsetof(struct dirent, d_name) + len;
           if (sz > bufsz)
             {
               bufsz *= 2;
diff -Paur --no-dereference -- make.upstream/src/function.c make/src/function.c
--- make.upstream/src/function.c
+++ make/src/function.c
@@ -2279,36 +2279,23 @@
           char *rp;
           struct stat st;
           PATH_VAR (in);
-          PATH_VAR (out);
 
           strncpy (in, path, len);
           in[len] = '\0';
 
-#ifdef HAVE_REALPATH
-          ENULLLOOP (rp, realpath (in, out));
-# if defined _AIX
-          /* AIX realpath() doesn't remove trailing slashes correctly.  */
-          if (rp)
-            {
-              char *ep = rp + strlen (rp) - 1;
-              while (ep > rp && ep[0] == '/')
-                *(ep--) = '\0';
-            }
-# endif
-#else
-          rp = abspath (in, out);
-#endif
+          ENULLLOOP (rp, realpath (in, NULL));
 
           if (rp)
             {
               int r;
-              EINTRLOOP (r, stat (out, &st));
+              EINTRLOOP (r, stat (rp, &st));
               if (r == 0)
                 {
-                  o = variable_buffer_output (o, out, strlen (out));
+                  o = variable_buffer_output (o, rp, strlen (rp));
                   o = variable_buffer_output (o, " ", 1);
                   doneany = 1;
                 }
+              free (rp);
             }
         }
     }
diff -Paur --no-dereference -- make.upstream/src/job.c make/src/job.c
--- make.upstream/src/job.c
+++ make/src/job.c
@@ -74,6 +74,11 @@
 # define VMS_POSIX_EXIT_MASK (C_FACILITY_NO | 0xA000)
 #endif
 
+#elif defined (__sortix__)
+
+char const *default_shell = "sh";
+int batch_mode_shell = 0;
+
 #else
 
 const char *default_shell = "/bin/sh";
diff -Paur --no-dereference -- make.upstream/src/main.c make/src/main.c
--- make.upstream/src/main.c
+++ make/src/main.c
@@ -2768,9 +2768,9 @@
           if (restarts)
             {
               char *b = alloca (40);
-              sprintf (b, "MAKE_RESTARTS=%s%u",
+              sprintf (b, "%s%u",
                        OUTPUT_IS_TRACED () ? "-" : "", restarts);
-              putenv (b);
+              setenv ("MAKE_RESTARTS", b, 1);
             }
 
           fflush (stdout);
diff -Paur --no-dereference -- make.upstream/src/misc.c make/src/misc.c
--- make.upstream/src/misc.c
+++ make/src/misc.c
@@ -877,6 +877,9 @@
 unsigned int
 get_path_max (void)
 {
+#if defined(__sortix__)
+  return 32768;
+#else
   static unsigned int value;
 
   if (value == 0)
@@ -889,6 +892,7 @@
     }
 
   return value;
+#endif
 }
 #endif
 
diff -Paur --no-dereference -- make.upstream/src/posixos.c make/src/posixos.c
--- make.upstream/src/posixos.c
+++ make/src/posixos.c
@@ -722,6 +722,7 @@
 {
   if (osync_enabled())
     {
+#ifdef F_SETLKW
       struct flock fl;
 
       fl.l_type = F_WRLCK;
@@ -734,6 +735,7 @@
           perror ("fcntl()");
           return 0;
         }
+#endif
     }
 
   return 1;
@@ -744,6 +746,7 @@
 {
   if (osync_enabled())
     {
+#ifdef F_SETLKW
       struct flock fl;
 
       fl.l_type = F_UNLCK;
@@ -753,6 +756,7 @@
       /* We don't want to keep waiting on EINTR.  */
       if (fcntl (osync_handle, F_SETLKW, &fl) == -1)
         perror ("fcntl()");
+#endif
     }
 }
 
