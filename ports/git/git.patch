diff -Paur --no-dereference -- git.upstream/Makefile git/Makefile
--- git.upstream/Makefile
+++ git/Makefile
@@ -649,7 +649,9 @@
 MSGCAT = msgcat
 MSGFMT = msgfmt
 MSGMERGE = msgmerge
-CURL_CONFIG = curl-config
+# PATCH: Always use pkg-config instead of the cross unsafe curl-config.
+PKG_CONFIG ?= pkg-config
+CURL_CONFIG = $(PKG_CONFIG) libcurl
 GCOV = gcov
 STRIP = strip
 SPATCH = spatch
@@ -2878,8 +2880,9 @@
 doc: man-perl
 	$(MAKE) -C Documentation all
 
-man: man-perl
-	$(MAKE) -C Documentation man
+# PATCH: Build manual pages if asciidoc and xmlto are installed.
+man: man
+	if which asciidoc 1>/dev/null 2>/dev/null && which xmlto 1>/dev/null 2>/dev/null; then $(MAKE) -C Documentation man; fi
 
 man-perl: perl/build/man/man3/Git.3pm
 
@@ -3479,7 +3482,7 @@
 
 INSTALL_STRIP =
 
-install: all
+install: all install-man
 	$(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(bindir_SQ)'
 	$(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
 	$(INSTALL) $(INSTALL_STRIP) $(PROGRAMS) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
@@ -3575,8 +3578,9 @@
 install-doc: install-man-perl
 	$(MAKE) -C Documentation install
 
-install-man: install-man-perl
-	$(MAKE) -C Documentation install-man
+# PATCH: Build manual pages if asciidoc and xmlto are installed.
+install-man:
+	if which asciidoc 1>/dev/null 2>/dev/null && which xmlto 1>/dev/null 2>/dev/null; then $(MAKE) -C Documentation install-man; fi
 
 install-man-perl: man-perl
 	$(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(mandir_SQ)/man3'
@@ -3683,8 +3687,8 @@
 
 ### Cleaning rules
 
+# PATCH: Don't delete configure when making distclean because it is in the dist.
 distclean: clean
-	$(RM) configure
 	$(RM) config.log config.status config.cache
 	$(RM) config.mak.autogen config.mak.append
 	$(RM) -r autom4te.cache
diff -Paur --no-dereference -- git.upstream/builtin/gc.c git/builtin/gc.c
--- git.upstream/builtin/gc.c
+++ git/builtin/gc.c
@@ -1783,7 +1783,7 @@
 
 static char *launchctl_get_uid(void)
 {
-	return xstrfmt("gui/%d", getuid());
+	return xstrfmt("gui/%jd", (intmax_t)getuid());
 }
 
 static int launchctl_boot_plist(int enable, const char *filename)
diff -Paur --no-dereference -- git.upstream/builtin/log.c git/builtin/log.c
--- git.upstream/builtin/log.c
+++ git/builtin/log.c
@@ -404,7 +404,12 @@
 	fprintf(rev->diffopt.file, _("Final output: %d %s\n"), nr, stage);
 }
 
+/* PATCH: Sortix does not have obsolescent XSI itimers. */
+#if defined(__sortix__)
+static timer_t early_output_timer;
+#else
 static struct itimerval early_output_timer;
+#endif
 
 static void log_show_early(struct rev_info *revs, struct commit_list *list)
 {
@@ -453,9 +458,18 @@
 	 * trigger every second even if we're blocked on a
 	 * reader!
 	 */
+#if defined(__sortix__)
+	struct itimerspec its;
+	its.it_value.tv_sec = 0;
+	its.it_value.tv_nsec = 500000000;
+	its.it_interval.tv_sec = 0;
+	its.it_interval.tv_nsec = 0;
+	timer_settime(early_output_timer, 0, &its, NULL);
+#else
 	early_output_timer.it_value.tv_sec = 0;
 	early_output_timer.it_value.tv_usec = 500000;
 	setitimer(ITIMER_REAL, &early_output_timer, NULL);
+#endif
 }
 
 static void early_output(int signal UNUSED)
@@ -465,6 +479,13 @@
 
 static void setup_early_output(void)
 {
+#if defined(__sortix__) && !defined(__SORTIX_HAS_RESTARTABLE_SYSCALLS__)
+	/* TODO: Sortix doesn't have restartable system calls at the moment and this
+	         feature creates spurious failures, so this feature is disabled for
+	         now. */
+	return;
+#endif
+
 	struct sigaction sa;
 
 	/*
@@ -487,13 +508,37 @@
 	 *
 	 * This is a one-time-only trigger.
 	 */
+#if defined(__sortix__)
+	struct sigevent sev;
+	memset(&sev, 0, sizeof(sev));
+	sev.sigev_notify = SIGEV_SIGNAL;
+	sev.sigev_signo = SIGALRM;
+	timer_create(CLOCK_MONOTONIC, &sev, &early_output_timer);
+	struct itimerspec its;
+	its.it_value.tv_sec = 0;
+	its.it_value.tv_nsec = 100000000;
+	its.it_interval.tv_sec = 0;
+	its.it_interval.tv_nsec = 0;
+	timer_settime(early_output_timer, 0, &its, NULL);
+#else
 	early_output_timer.it_value.tv_sec = 0;
 	early_output_timer.it_value.tv_usec = 100000;
 	setitimer(ITIMER_REAL, &early_output_timer, NULL);
+#endif
 }
 
 static void finish_early_output(struct rev_info *rev)
 {
+#if defined(__sortix__) && !defined(__SORTIX_HAS_RESTARTABLE_SYSCALLS__)
+	/* TODO: Sortix doesn't have restartable system calls at the moment and this
+	         feature creates spurious failures, so this feature is disabled for
+	         now. */
+	return;
+#endif
+
+#if defined(__sortix__)
+	timer_delete(early_output_timer);
+#endif
 	int n = estimate_commit_count(rev->commits);
 	signal(SIGALRM, SIG_IGN);
 	show_early_header(rev, "done", n);
diff -Paur --no-dereference -- git.upstream/compat/hstrerror.c git/compat/hstrerror.c
--- git.upstream/compat/hstrerror.c
+++ git/compat/hstrerror.c
@@ -2,6 +2,10 @@
 #include <stdio.h>
 #include <netdb.h>
 
+/* PATCH: hstrerror(3) is not used by git when getaddrinfo(3) is available.
+          Sortix has the modern getaddrinfo(3), but does not have the obsolete
+          gethostbyname(3). */
+#ifdef NO_IPV6
 const char *githstrerror(int err)
 {
 	static char buffer[48];
@@ -19,3 +23,4 @@
 	snprintf(buffer, sizeof(buffer), "Name resolution error %d", err);
 	return buffer;
 }
+#endif
diff -Paur --no-dereference -- git.upstream/config.mak.uname git/config.mak.uname
--- git.upstream/config.mak.uname
+++ git/config.mak.uname
@@ -40,6 +40,8 @@
 # because maintaining the nesting to match is a pain.  If
 # we had "elif" things would have been much nicer...
 
+# PATCH: Assume unknown operating systems have /dev/tty as required by POSIX.
+HAVE_DEV_TTY = YesPlease
 ifeq ($(uname_S),OSF1)
 	# Need this for u_short definitions et al
 	BASIC_CFLAGS += -D_OSF_SOURCE
@@ -60,10 +62,12 @@
 	HAVE_SYNC_FILE_RANGE = YesPlease
 	HAVE_GETDELIM = YesPlease
 	FREAD_READS_DIRECTORIES = UnfortunatelyYes
-	BASIC_CFLAGS += -DHAVE_SYSINFO
-	PROCFS_EXECUTABLE_PATH = /proc/self/exe
-	HAVE_PLATFORM_PROCINFO = YesPlease
-	COMPAT_OBJS += compat/linux/procinfo.o
+	# PATCH: Unfortunately this whole system isn't cross safe and isn't fully
+	#        overriden by config.mak.autogen.
+	#BASIC_CFLAGS += -DHAVE_SYSINFO
+	#PROCFS_EXECUTABLE_PATH = /proc/self/exe
+	#HAVE_PLATFORM_PROCINFO = YesPlease
+	#COMPAT_OBJS += compat/linux/procinfo.o
 	# centos7/rhel7 provides gcc 4.8.5 and zlib 1.2.7.
         ifneq ($(findstring .el7.,$(uname_R)),)
 		BASIC_CFLAGS += -std=c99
diff -Paur --no-dereference -- git.upstream/configure git/configure
--- git.upstream/configure
+++ git/configure
@@ -5466,7 +5466,7 @@
   printf %s "(cached) " >&6
 else $as_nop
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcurl  $LIBS"
+LIBS="-lcurl -lssl -lcrypto -lz $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -5516,49 +5516,7 @@
 
 if test -z "$NO_CURL"; then
 
-# Extract the first word of "curl-config", so it can be a program name with args.
-set dummy curl-config; ac_word=$2
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-printf %s "checking for $ac_word... " >&6; }
-if test ${ac_cv_prog_CURL_CONFIG+y}
-then :
-  printf %s "(cached) " >&6
-else $as_nop
-  if test -n "$CURL_CONFIG"; then
-  ac_cv_prog_CURL_CONFIG="$CURL_CONFIG" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  case $as_dir in #(((
-    '') as_dir=./ ;;
-    */) ;;
-    *) as_dir=$as_dir/ ;;
-  esac
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CURL_CONFIG="curl-config"
-    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_prog_CURL_CONFIG" && ac_cv_prog_CURL_CONFIG="no"
-fi
-fi
-CURL_CONFIG=$ac_cv_prog_CURL_CONFIG
-if test -n "$CURL_CONFIG"; then
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CURL_CONFIG" >&5
-printf "%s\n" "$CURL_CONFIG" >&6; }
-else
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
-printf "%s\n" "no" >&6; }
-fi
-
-
+# PATCH: Do not use the cross unsafe curl-config.
 
 if test $CURL_CONFIG != no; then
 
@@ -6240,10 +6198,8 @@
 
 if test "$cross_compiling" = yes
 then :
-  { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run test program while cross compiling
-See \`config.log' for more details" "$LINENO" 5; }
+# PATCH: Guess iconv does not omit the BOM.
+ac_cv_iconv_omits_bom=no
 else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
diff -Paur --no-dereference -- git.upstream/dir.c git/dir.c
--- git.upstream/dir.c
+++ git/dir.c
@@ -3392,10 +3392,15 @@
 				continue;
 			/* fall through */
 		} else if (S_ISDIR(st.st_mode)) {
-			if (!remove_dir_recurse(path, flag, &kept_down))
+			if (!remove_dir_recurse(path, flag, &kept_down)) {
+				/* PATCH: Sortix readdir is not consistently ordered after
+				          unlink at this time. */
+				rewinddir(dir);
 				continue; /* happy */
+			}
 		} else if (!only_empty &&
 			   (!unlink(path->buf) || errno == ENOENT)) {
+			rewinddir(dir);
 			continue; /* happy, too */
 		}
 
diff -Paur --no-dereference -- git.upstream/git-compat-util.h git/git-compat-util.h
--- git.upstream/git-compat-util.h
+++ git/git-compat-util.h
@@ -443,7 +443,14 @@
 typedef uintmax_t timestamp_t;
 #define PRItime PRIuMAX
 #define parse_timestamp strtoumax
+/* PATCH: Avoid conflicting Sortix macros. */
+#ifdef TIME_MAX
+#undef TIME_MAX
+#endif
 #define TIME_MAX UINTMAX_MAX
+#ifdef TIME_MIN
+#undef TIME_MIN
+#endif
 #define TIME_MIN 0
 
 #ifndef PATH_SEP
diff -Paur --no-dereference -- git.upstream/lockfile.c git/lockfile.c
--- git.upstream/lockfile.c
+++ git/lockfile.c
@@ -107,16 +107,10 @@
 	int n = 1;
 	int multiplier = 1;
 	long remaining_ms = 0;
-	static int random_initialized = 0;
 
 	if (timeout_ms == 0)
 		return lock_file(lk, path, flags, mode);
 
-	if (!random_initialized) {
-		srand((unsigned int)getpid());
-		random_initialized = 1;
-	}
-
 	if (timeout_ms > 0)
 		remaining_ms = timeout_ms;
 
@@ -135,7 +129,8 @@
 
 		backoff_ms = multiplier * INITIAL_BACKOFF_MS;
 		/* back off for between 0.75*backoff_ms and 1.25*backoff_ms */
-		wait_ms = (750 + rand() % 500) * backoff_ms / 1000;
+		/* PATCH: Avoid rand(3) warning and modulo bias. */
+		wait_ms = (750 + arc4random_uniform(500)) * backoff_ms / 1000;
 		sleep_millisec(wait_ms);
 		remaining_ms -= wait_ms;
 
diff -Paur --no-dereference -- git.upstream/progress.c git/progress.c
--- git.upstream/progress.c
+++ git/progress.c
@@ -49,6 +49,10 @@
 	int split;
 };
 
+/* PATCH: Sortix does not have obsolescent XSI itimers. */
+#if defined(__sortix__)
+static timer_t progress_timer;
+#endif
 static volatile sig_atomic_t progress_update;
 
 /*
@@ -70,8 +74,19 @@
 
 static void set_progress_signal(void)
 {
+#if defined(__sortix__) && !defined(__SORTIX_HAS_RESTARTABLE_SYSCALLS__)
+	/* TODO: Sortix doesn't have restartable system calls at the moment and this
+	         feature creates spurious failures, so this feature is disabled for
+	         now. */
+	return;
+#endif
+
 	struct sigaction sa;
+#if defined(__sortix__)
+	struct itimerspec v;
+#else
 	struct itimerval v;
+#endif
 
 	if (progress_testing)
 		return;
@@ -84,20 +99,43 @@
 	sa.sa_flags = SA_RESTART;
 	sigaction(SIGALRM, &sa, NULL);
 
+#if defined(__sortix__)
+	struct sigevent sev;
+	memset(&sev, 0, sizeof(sev));
+	sev.sigev_notify = SIGEV_SIGNAL;
+	sev.sigev_signo = SIGALRM;
+	timer_create(CLOCK_MONOTONIC, &sev, &progress_timer);
+	v.it_interval.tv_sec = 1;
+	v.it_interval.tv_nsec = 0;
+	v.it_value = v.it_interval;
+	timer_settime(progress_timer, 0, &v, NULL);
+#else
 	v.it_interval.tv_sec = 1;
 	v.it_interval.tv_usec = 0;
 	v.it_value = v.it_interval;
 	setitimer(ITIMER_REAL, &v, NULL);
+#endif
 }
 
 static void clear_progress_signal(void)
 {
+#if defined(__sortix__) && !defined(__SORTIX_HAS_RESTARTABLE_SYSCALLS__)
+	/* TODO: Sortix doesn't have restartable system calls at the moment and this
+	         feature creates spurious failures, so this feature is disabled for
+	         now. */
+	return;
+#endif
+
 	struct itimerval v = {{0,},};
 
 	if (progress_testing)
 		return;
 
+#if defined(__sortix__)
+	timer_delete(progress_timer);
+#else
 	setitimer(ITIMER_REAL, &v, NULL);
+#endif
 	signal(SIGALRM, SIG_IGN);
 	progress_update = 0;
 }
diff -Paur --no-dereference -- git.upstream/run-command.c git/run-command.c
--- git.upstream/run-command.c
+++ git/run-command.c
@@ -522,9 +522,12 @@
 #else
 	CHECK_BUG(pthread_sigmask(SIG_SETMASK, &all, &as->old),
 		"blocking all signals");
+/* PATCH: Sortix doesn't have pthread cancelation. */
+#ifdef PTHREAD_CANCEL_DISABLE
 	CHECK_BUG(pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &as->cs),
 		"disabling cancellation");
 #endif
+#endif
 }
 
 static void atfork_parent(struct atfork_state *as)
@@ -533,8 +536,11 @@
 	if (sigprocmask(SIG_SETMASK, &as->old, NULL))
 		die_errno("sigprocmask");
 #else
+/* PATCH: Sortix doesn't have pthread cancelation. */
+#ifdef PTHREAD_CANCEL_DISABLE
 	CHECK_BUG(pthread_setcancelstate(as->cs, NULL),
 		"re-enabling cancellation");
+#endif
 	CHECK_BUG(pthread_sigmask(SIG_SETMASK, &as->old, NULL),
 		"restoring signal mask");
 #endif
