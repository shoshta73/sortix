diff -Paur --no-dereference -- xargs.upstream/Makefile xargs/Makefile
--- xargs.upstream/Makefile
+++ xargs/Makefile
@@ -0,0 +1,32 @@
+include ../../../build-aux/compiler.mak
+include ../../../build-aux/version.mak
+include ../../../build-aux/dirs.mak
+
+OPTLEVEL?=$(DEFAULT_OPTLEVEL)
+CFLAGS?=$(OPTLEVEL)
+
+CFLAGS:=$(CXXFLAGS) -Wall -Wextra
+CPPFLAGS:=$(CPPFLAGS)
+
+BINARY:=xargs
+MANPAGE=xargs.1
+OBJS=xargs.o strnsubst.o
+
+all: $(BINARY)
+
+.PHONY: all install clean
+
+$(BINARY): $(OBJS)
+	$(CC) $(CFLAGS) -o $(BINARY) $(OBJS)
+
+%: %.c
+	$(CC) -std=gnu11 $(CFLAGS) $(CPPFLAGS) $< -o $@ $(LIBS)
+
+install: all
+	mkdir -p $(DESTDIR)$(BINDIR)
+	install $(BINARY) $(DESTDIR)$(BINDIR)
+	mkdir -p $(DESTDIR)$(MANDIR)/man1
+	install $(MANPAGE) $(DESTDIR)$(MANDIR)/man1
+
+clean:
+	rm -f $(BINARY) $(OBJS)
diff -Paur --no-dereference -- xargs.upstream/xargs.1 xargs/xargs.1
--- xargs.upstream/xargs.1
+++ xargs/xargs.1
@@ -0,0 +1,347 @@
+.\"	$OpenBSD: xargs.1,v 1.29 2020/07/19 13:19:25 schwarze Exp $
+.\"	$FreeBSD: xargs.1,v 1.30 2003/05/21 21:07:28 ru Exp $$
+.\"
+.\" Copyright (c) 1990, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" This code is derived from software contributed to Berkeley by
+.\" John B. Roll Jr. and the Institute of Electrical and Electronics
+.\" Engineers, Inc.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"	@(#)xargs.1	8.1 (Berkeley) 6/6/93
+.\"
+.Dd $Mdocdate: July 19 2020 $
+.Dt XARGS 1
+.Os
+.Sh NAME
+.Nm xargs
+.Nd construct argument list(s) and execute utility
+.Sh SYNOPSIS
+.Nm xargs
+.Bk -words
+.Op Fl 0oprt
+.Op Fl E Ar eofstr
+.Oo
+.Fl I Ar replstr
+.Op Fl R Ar replacements
+.Oc
+.Op Fl J Ar replstr
+.Op Fl L Ar number
+.Oo
+.Fl n Ar number
+.Op Fl x
+.Oc
+.Op Fl P Ar maxprocs
+.Op Fl s Ar size
+.Op Ar utility Op Ar argument ...
+.Ek
+.Sh DESCRIPTION
+The
+.Nm
+utility reads space, tab, newline, and end-of-file delimited strings
+from the standard input and executes the specified
+.Ar utility
+with the strings as
+arguments.
+.Pp
+Any arguments specified on the command line are given to the
+.Ar utility
+upon each invocation, followed by some number of the arguments read
+from standard input.
+The
+.Ar utility
+is repeatedly executed one or more times until standard input
+is exhausted.
+.Pp
+Spaces, tabs and newlines may be embedded in arguments using single
+.Pq Ql '
+or double
+.Pq Ql \&"
+quotes or backslashes
+.Pq Ql \e .
+Single quotes escape all non-single quote characters, excluding newlines,
+up to the matching single quote.
+Double quotes escape all non-double quote characters, excluding newlines,
+up to the matching double quote.
+Any single character, including newlines, may be escaped by a backslash.
+.Pp
+The options are as follows:
+.Bl -tag -width Ds
+.It Fl 0
+Change
+.Nm
+to expect NUL
+.Pq Ql \e0
+characters as separators, instead of spaces and newlines.
+The quoting mechanisms described above are not performed.
+This option is expected to be used in concert with the
+.Fl print0
+function in
+.Xr find 1 .
+.It Fl E Ar eofstr
+Use
+.Ar eofstr
+as a logical EOF marker.
+.It Fl I Ar replstr
+Execute
+.Ar utility
+for each input line, replacing one or more occurrences of
+.Ar replstr
+in up to
+.Ar replacements
+(or 5 if no
+.Fl R
+flag is specified) arguments to
+.Ar utility
+with the entire line of input.
+The resulting arguments, after replacement is done, will not be allowed to grow
+beyond 255 bytes; this is implemented by concatenating as much of the argument
+containing
+.Ar replstr
+as possible, to the constructed arguments to
+.Ar utility ,
+up to 255 bytes.
+The 255 byte limit does not apply to arguments to
+.Ar utility
+which do not contain
+.Ar replstr ,
+and furthermore, no replacement will be done on
+.Ar utility
+itself.
+Implies
+.Fl x .
+.It Fl J Ar replstr
+If this option is specified,
+.Nm
+will use the data read from standard input to replace the first occurrence of
+.Ar replstr
+instead of appending that data after all other arguments.
+This option will not effect how many arguments will be read from input
+.Pq Fl n ,
+or the size of the command(s)
+.Nm
+will generate
+.Pq Fl s .
+The option just moves where those arguments will be placed in the command(s)
+that are executed.
+The
+.Ar replstr
+must show up as a distinct
+.Ar argument
+to
+.Nm xargs .
+It will not be recognized if, for instance, it is in the middle of a
+quoted string.
+Furthermore, only the first occurrence of the
+.Ar replstr
+will be replaced.
+For example, the following command will copy the list of files and
+directories which start with an uppercase letter in the current
+directory to
+.Pa destdir :
+.Pp
+.Dl "/bin/ls -1d [A-Z]* | xargs -J % cp -Rp % destdir"
+.It Fl L Ar number
+Call
+.Ar utility
+for every
+.Ar number
+of non-empty lines read.
+A line ending in unescaped white space and the next non-empty line
+are considered to form one single line.
+If EOF is reached and fewer than
+.Ar number
+lines have been read then
+.Ar utility
+will be called with the available lines.
+.It Fl n Ar number
+Set the maximum number of arguments taken from standard input for each
+invocation of
+.Ar utility .
+An invocation of
+.Ar utility
+will use less than
+.Ar number
+standard input arguments if the number of bytes accumulated (see the
+.Fl s
+option) exceeds the specified
+.Ar size
+or there are fewer than
+.Ar number
+arguments remaining for the last invocation of
+.Ar utility .
+The current default value for
+.Ar number
+is 5000.
+.It Fl o
+Reopen stdin as
+.Pa /dev/tty
+in the child process before executing the command.
+This is useful if you want
+.Nm
+to run an interactive application.
+.It Fl P Ar maxprocs
+Parallel mode: run at most
+.Ar maxprocs
+invocations of
+.Ar utility
+at once.
+.It Fl p
+Echo each command to be executed and ask the user whether it should be
+executed.
+If the answer starts with
+.Ql y
+or
+.Ql Y ,
+the command is executed; otherwise it is skipped.
+No commands are executed if the process is not attached to a terminal.
+.It Fl R Ar replacements
+Specify the maximum number of arguments that
+.Fl I
+will do replacement in.
+If
+.Ar replacements
+is negative, the number of arguments in which to replace is unbounded.
+.It Fl r
+Do not run the command if there are no arguments.
+Normally the command is executed at least once
+even if there are no arguments.
+.It Fl s Ar size
+Set the maximum number of bytes for the command line length provided to
+.Ar utility .
+The sum of the length of the utility name, the arguments passed to
+.Ar utility
+(including
+.Dv NUL
+terminators) and the current environment will be less than or equal to
+this number.
+The current default value for
+.Ar size
+is
+.Dv ARG_MAX
+- 4096.
+.It Fl t
+Echo the command to be executed to standard error immediately before it
+is executed.
+.It Fl x
+Force
+.Nm
+to terminate immediately if a command line containing
+.Ar number
+arguments will not fit in the specified (or default) command line length.
+.El
+.Pp
+If no
+.Ar utility
+is specified,
+.Xr echo 1
+is used.
+.Pp
+Undefined behavior may occur if
+.Ar utility
+reads from the standard input.
+.Pp
+The
+.Nm
+utility exits immediately (without processing any further input) if a
+command line cannot be assembled,
+.Ar utility
+cannot be invoked, an invocation of
+.Ar utility
+is terminated by a signal,
+or an invocation of
+.Ar utility
+exits with a value of 255.
+.Sh EXIT STATUS
+.Nm
+exits with one of the following values:
+.Pp
+.Bl -tag -width Ds -offset indent -compact
+.It 0
+All invocations of
+.Ar utility
+returned a zero exit status.
+.It 123
+One or more invocations of
+.Ar utility
+returned a nonzero exit status.
+.It 124
+The
+.Ar utility
+exited with a 255 exit status.
+.It 125
+The
+.Ar utility
+was killed or stopped by a signal.
+.It 126
+The
+.Ar utility
+was found but could not be executed.
+.It 127
+The
+.Ar utility
+could not be found.
+.It 1
+Some other error occurred.
+.El
+.Sh SEE ALSO
+.Xr echo 1 ,
+.Xr find 1 ,
+.Xr execvp 3
+.Sh STANDARDS
+The
+.Nm
+utility is compliant with the
+.St -p1003.1-2008
+specification.
+.Pp
+The flags
+.Op Fl IL
+are marked by
+.St -p1003.1-2008
+as being an X/Open System Interfaces option.
+.Pp
+The flags
+.Op Fl 0JoPRr
+are extensions to
+.St -p1003.1-2008 .
+.Pp
+The meanings of the 123, 124, and 125 exit values were taken from GNU
+.Nm xargs .
+.Sh HISTORY
+The
+.Nm
+command appeared in PWB
+.Ux .
+.Sh BUGS
+If
+.Ar utility
+attempts to invoke another command such that the number of arguments or the
+size of the environment is increased, it risks
+.Xr execvp 3
+failing with
+.Er E2BIG .
diff -Paur --no-dereference -- xargs.upstream/strnsubst.c xargs/strnsubst.c
--- xargs.upstream/strnsubst.c
+++ xargs/strnsubst.c
@@ -0,0 +1,66 @@
+/*	$OpenBSD: strnsubst.c,v 1.8 2023/04/19 12:58:16 jsg Exp $	*/
+/*	$FreeBSD: strnsubst.c,v 1.6 2002/06/22 12:58:42 jmallett Exp $	*/
+
+/*
+ * Copyright (c) 2002 J. Mallett.  All rights reserved.
+ * You may do whatever you want with this file as long as
+ * the above copyright and this notice remain intact, along
+ * with the following statement:
+ * 	For the man who taught me vi, and who got too old, too young.
+ */
+
+#include <err.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+void	strnsubst(char **, const char *, const char *, size_t);
+
+/*
+ * Replaces str with a string consisting of str with match replaced with
+ * replstr as many times as can be done before the constructed string is
+ * maxsize bytes large.  It does not free the string pointed to by str, it
+ * is up to the calling program to be sure that the original contents of
+ * str as well as the new contents are handled in an appropriate manner.
+ * If replstr is NULL, then that internally is changed to a nil-string, so
+ * that we can still pretend to do somewhat meaningful substitution.
+ * No value is returned.
+ */
+void
+strnsubst(char **str, const char *match, const char *replstr, size_t maxsize)
+{
+	char *s1, *s2, *this;
+	size_t matchlen, s2len;
+	int n;
+
+	if ((s1 = *str) == NULL)
+		return;
+	if ((s2 = malloc(maxsize)) == NULL)
+		err(1, NULL);
+
+	if (replstr == NULL)
+		replstr = "";
+
+	if (match == NULL || *match == '\0' || strlen(s1) >= maxsize) {
+		strlcpy(s2, s1, maxsize);
+		goto done;
+	}
+
+	*s2 = '\0';
+	s2len = 0;
+	matchlen = strlen(match);
+	for (;;) {
+		if ((this = strstr(s1, match)) == NULL)
+			break;
+		n = snprintf(s2 + s2len, maxsize - s2len, "%.*s%s",
+		    (int)(this - s1), s1, replstr);
+		if (n < 0 || n + s2len + strlen(this + matchlen) >= maxsize)
+			break;			/* out of room */
+		s2len += n;
+		s1 = this + matchlen;
+	}
+	strlcpy(s2 + s2len, s1, maxsize - s2len);
+done:
+	*str = s2;
+}
diff -Paur --no-dereference -- xargs.upstream/xargs.c xargs/xargs.c
--- xargs.upstream/xargs.c
+++ xargs/xargs.c
@@ -0,0 +1,625 @@
+/*	$OpenBSD: xargs.c,v 1.38 2023/12/23 15:58:58 millert Exp $	*/
+/*	$FreeBSD: xargs.c,v 1.51 2003/05/03 19:09:11 obrien Exp $	*/
+
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * John B. Roll Jr.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $xMach: xargs.c,v 1.6 2002/02/23 05:27:47 tim Exp $
+ */
+
+#include <sys/wait.h>
+
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+
+// Sortix: <paths.h> not implemented
+#define _PATH_DEVNULL "/dev/null"
+#define _PATH_ECHO "/bin/echo"
+#define _PATH_TTY "/dev/tty"
+
+static void	parse_input(int, char *[]);
+static void	prerun(int, char *[]);
+static int	prompt(void);
+static void	run(char **);
+static void	usage(void);
+void		strnsubst(char **, const char *, const char *, size_t);
+static void	waitchildren(const char *, int);
+
+static char **av, **bxp, **ep, **endxp, **xp;
+static char *argp, *bbp, *ebp, *inpline, *p, *replstr;
+static const char *eofstr;
+static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
+static int cnt, Iflag, jfound, Lflag, wasquoted, xflag, runeof = 1;
+static int curprocs, maxprocs;
+static size_t inpsize;
+
+extern char **environ;
+
+int
+main(int argc, char *argv[])
+{
+	long arg_max;
+	int ch, Jflag, nargs, nflag, nline;
+	size_t linelen;
+	char *endptr;
+
+	inpline = replstr = NULL;
+	ep = environ;
+	eofstr = "";
+	Jflag = nflag = 0;
+
+	/*
+	 * POSIX.2 limits the exec line length to ARG_MAX - 2K.  Running that
+	 * caused some E2BIG errors, so it was changed to ARG_MAX - 4K.  Given
+	 * that the smallest argument is 2 bytes in length, this means that
+	 * the number of arguments is limited to:
+	 *
+	 *	 (ARG_MAX - 4K - LENGTH(utility + arguments)) / 2.
+	 *
+	 * We arbitrarily limit the number of arguments to 5000.  This is
+	 * allowed by POSIX.2 as long as the resulting minimum exec line is
+	 * at least LINE_MAX.  Realloc'ing as necessary is possible, but
+	 * probably not worthwhile.
+	 */
+	nargs = 5000;
+	arg_max = 4096 * 16;
+	nline = arg_max - 4 * 1024;
+	while (*ep != NULL) {
+		/* 1 byte for each '\0' */
+		nline -= strlen(*ep++) + 1 + sizeof(*ep);
+	}
+	maxprocs = 1;
+	while ((ch = getopt(argc, argv, "0E:I:J:L:n:oP:pR:rs:tx")) != -1)
+		switch (ch) {
+		case 'E':
+			eofstr = optarg;
+			break;
+		case 'I':
+			Jflag = 0;
+			Iflag = 1;
+			Lflag = 1;
+			replstr = optarg;
+			break;
+		case 'J':
+			Iflag = 0;
+			Jflag = 1;
+			replstr = optarg;
+			break;
+		case 'L':
+			Lflag = atoi(optarg);
+			break;
+		case 'n':
+			nflag = 1;
+			if ((nargs = atoi(optarg)) <= 0)
+				errx(1, "illegal argument count");
+			break;
+		case 'o':
+			oflag = 1;
+			break;
+		case 'P':
+			if ((maxprocs = atoi(optarg)) <= 0)
+				errx(1, "-P argument must be >0");
+			break;
+		case 'p':
+			pflag = 1;
+			break;
+		case 'r':
+			runeof = 0;
+			break;
+		case 'R':
+			Rflag = strtol(optarg, &endptr, 10);
+			if (*endptr != '\0')
+				errx(1, "replacements must be a number");
+			break;
+		case 's':
+			nline = strtol(optarg, &endptr, 10);
+			if (*endptr != '\0')
+				errx(1, "-s argument must be a number");
+			break;
+		case 't':
+			tflag = 1;
+			break;
+		case 'x':
+			xflag = 1;
+			break;
+		case '0':
+			zflag = 1;
+			break;
+		default:
+			usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (!Iflag && Rflag)
+		usage();
+	if (Iflag && !Rflag)
+		Rflag = 5;
+	if (xflag && !nflag)
+		usage();
+	if (Iflag || Lflag)
+		xflag = 1;
+	if (replstr != NULL && *replstr == '\0')
+		errx(1, "replstr may not be empty");
+
+	/*
+	 * Allocate pointers for the utility name, the utility arguments,
+	 * the maximum arguments to be read from stdin and the trailing
+	 * NULL.
+	 */
+	linelen = 1 + argc + nargs + 1;
+	if ((av = bxp = calloc(linelen, sizeof(char *))) == NULL)
+		err(1, NULL);
+
+	/*
+	 * Use the user's name for the utility as argv[0], just like the
+	 * shell.  Echo is the default.  Set up pointers for the user's
+	 * arguments.
+	 */
+	if (*argv == NULL)
+		cnt = strlen(*bxp++ = _PATH_ECHO);
+	else {
+		do {
+			if (Jflag && strcmp(*argv, replstr) == 0) {
+				char **avj;
+				jfound = 1;
+				argv++;
+				for (avj = argv; *avj; avj++)
+					cnt += strlen(*avj) + 1;
+				break;
+			}
+			cnt += strlen(*bxp++ = *argv) + 1;
+		} while (*++argv != NULL);
+	}
+
+	/*
+	 * Set up begin/end/traversing pointers into the array.  The -n
+	 * count doesn't include the trailing NULL pointer, so the malloc
+	 * added in an extra slot.
+	 */
+	endxp = (xp = bxp) + nargs;
+
+	/*
+	 * Allocate buffer space for the arguments read from stdin and the
+	 * trailing NULL.  Buffer space is defined as the default or specified
+	 * space, minus the length of the utility name and arguments.  Set up
+	 * begin/end/traversing pointers into the array.  The -s count does
+	 * include the trailing NULL, so the malloc didn't add in an extra
+	 * slot.
+	 */
+	nline -= cnt;
+	if (nline <= 0)
+		errx(1, "insufficient space for command");
+
+	if ((bbp = malloc((size_t)(nline + 1))) == NULL)
+		err(1, NULL);
+	ebp = (argp = p = bbp) + nline - 1;
+	for (;;)
+		parse_input(argc, argv);
+}
+
+static void
+parse_input(int argc, char *argv[])
+{
+	int hasblank = 0;
+	static int hadblank = 0;
+	int ch, foundeof = 0;
+	char **avj;
+
+	ch = getchar();
+	if (isblank(ch)) {
+		/* Quotes escape tabs and spaces. */
+		if (insingle || indouble)
+			goto addch;
+		hasblank = 1;
+		if (zflag)
+			goto addch;
+		goto arg2;
+	}
+
+	switch (ch) {
+	case EOF:
+		/* No arguments since last exec. */
+		if (p == bbp) {
+			if (runeof)
+				prerun(0, av);
+			waitchildren(*argv, 1);
+			exit(rval);
+		}
+		goto arg1;
+	case '\0':
+		if (zflag) {
+			/*
+			 * Increment 'count', so that nulls will be treated
+			 * as end-of-line, as well as end-of-argument.  This
+			 * is needed so -0 works properly with -I and -L.
+			 */
+			count++;
+			goto arg2;
+		}
+		goto addch;
+	case '\n':
+		if (zflag)
+			goto addch;
+		hasblank = 1;
+		if (hadblank == 0)
+			count++;
+
+		/* Quotes do not escape newlines. */
+arg1:		if (insingle || indouble)
+			errx(1, "unterminated quote");
+arg2:
+		foundeof = *eofstr != '\0' &&
+		    strcmp(argp, eofstr) == 0;
+
+		/*
+		 * Do not make empty args unless they are quoted or
+		 * we are run as "find -0" and not at EOF.
+		 */
+		if (((zflag && ch != EOF) || argp != p || wasquoted) &&
+		    !foundeof) {
+			*p++ = '\0';
+			*xp++ = argp;
+			if (Iflag) {
+				size_t curlen;
+
+				if (inpline == NULL)
+					curlen = 0;
+				else {
+					/*
+					 * If this string is not zero
+					 * length, append a space for
+					 * separation before the next
+					 * argument.
+					 */
+					if ((curlen = strlen(inpline)))
+						strlcat(inpline, " ", inpsize);
+				}
+				curlen++;
+				/*
+				 * Allocate enough to hold what we will
+				 * be holding in a second, and to append
+				 * a space next time through, if we have
+				 * to.
+				 */
+				inpsize = curlen + 2 + strlen(argp);
+				inpline = realloc(inpline, inpsize);
+				if (inpline == NULL)
+					errx(1, "realloc failed");
+				if (curlen == 1)
+					strlcpy(inpline, argp, inpsize);
+				else
+					strlcat(inpline, argp, inpsize);
+			}
+		}
+
+		/*
+		 * If max'd out on args or buffer, or reached EOF,
+		 * run the command.  If xflag and max'd out on buffer
+		 * but not on args, object.  Having reached the limit
+		 * of input lines, as specified by -L is the same as
+		 * maxing out on arguments.
+		 */
+		if (xp == endxp || p > ebp || ch == EOF ||
+		    (Lflag <= count && xflag) || foundeof) {
+			if (xflag && xp != endxp && p > ebp)
+				errx(1, "insufficient space for arguments");
+			if (jfound) {
+				for (avj = argv; *avj; avj++)
+					*xp++ = *avj;
+			}
+			prerun(argc, av);
+			if (ch == EOF || foundeof) {
+				waitchildren(*argv, 1);
+				exit(rval);
+			}
+			p = bbp;
+			xp = bxp;
+			count = 0;
+		}
+		argp = p;
+		wasquoted = 0;
+		break;
+	case '\'':
+		if (indouble || zflag)
+			goto addch;
+		insingle = !insingle;
+		wasquoted = 1;
+		break;
+	case '"':
+		if (insingle || zflag)
+			goto addch;
+		indouble = !indouble;
+		wasquoted = 1;
+		break;
+	case '\\':
+		if (zflag)
+			goto addch;
+		/* Backslash escapes anything, is escaped by quotes. */
+		if (!insingle && !indouble && (ch = getchar()) == EOF)
+			errx(1, "backslash at EOF");
+		/* FALLTHROUGH */
+	default:
+addch:		if (p < ebp) {
+			*p++ = ch;
+			break;
+		}
+
+		/* If only one argument, not enough buffer space. */
+		if (bxp == xp)
+			errx(1, "insufficient space for argument");
+		/* Didn't hit argument limit, so if xflag object. */
+		if (xflag)
+			errx(1, "insufficient space for arguments");
+
+		if (jfound) {
+			for (avj = argv; *avj; avj++)
+				*xp++ = *avj;
+		}
+		prerun(argc, av);
+		xp = bxp;
+		cnt = ebp - argp;
+		memmove(bbp, argp, (size_t)cnt);
+		p = (argp = bbp) + cnt;
+		*p++ = ch;
+		break;
+	}
+	hadblank = hasblank;
+}
+
+/*
+ * Do things necessary before run()'ing, such as -I substitution,
+ * and then call run().
+ */
+static void
+prerun(int argc, char *argv[])
+{
+	char **tmp, **tmp2, **avj;
+	int repls;
+
+	repls = Rflag;
+	runeof = 0;
+
+	if (argc == 0 || repls == 0) {
+		*xp = NULL;
+		run(argv);
+		return;
+	}
+
+	avj = argv;
+
+	/*
+	 * Allocate memory to hold the argument list, and
+	 * a NULL at the tail.
+	 */
+	tmp = calloc(argc + 1, sizeof(char *));
+	if (tmp == NULL)
+		err(1, NULL);
+	tmp2 = tmp;
+
+	/*
+	 * Save the first argument and iterate over it, we
+	 * cannot do strnsubst() to it.
+	 */
+	if ((*tmp++ = strdup(*avj++)) == NULL)
+		err(1, NULL);
+
+	/*
+	 * For each argument to utility, if we have not used up
+	 * the number of replacements we are allowed to do, and
+	 * if the argument contains at least one occurrence of
+	 * replstr, call strnsubst(), else just save the string.
+	 * Iterations over elements of avj and tmp are done
+	 * where appropriate.
+	 */
+	while (--argc) {
+		*tmp = *avj++;
+		if (repls && strstr(*tmp, replstr) != NULL) {
+			strnsubst(tmp++, replstr, inpline, (size_t)255);
+			if (repls > 0)
+				repls--;
+		} else {
+			if ((*tmp = strdup(*tmp)) == NULL)
+				err(1, NULL);
+			tmp++;
+		}
+	}
+
+	/*
+	 * Run it.
+	 */
+	*tmp = NULL;
+	run(tmp2);
+
+	/*
+	 * Walk from the tail to the head, free along the way.
+	 */
+	for (; tmp2 != tmp; tmp--)
+		free(*tmp);
+	/*
+	 * Now free the list itself.
+	 */
+	free(tmp2);
+
+	/*
+	 * Free the input line buffer, if we have one.
+	 */
+	free(inpline);
+	inpline = NULL;
+}
+
+static void
+run(char **argv)
+{
+	pid_t pid;
+	int fd;
+	char **avec;
+
+	/*
+	 * If the user wants to be notified of each command before it is
+	 * executed, notify them.  If they want the notification to be
+	 * followed by a prompt, then prompt them.
+	 */
+	if (tflag || pflag) {
+		fprintf(stderr, "%s", *argv);
+		for (avec = argv + 1; *avec != NULL; ++avec)
+			fprintf(stderr, " %s", *avec);
+		/*
+		 * If the user has asked to be prompted, do so.
+		 */
+		if (pflag)
+			/*
+			 * If they asked not to exec, return without execution
+			 * but if they asked to, go to the execution.  If we
+			 * could not open their tty, break the switch and drop
+			 * back to -t behaviour.
+			 */
+			switch (prompt()) {
+			case 0:
+				return;
+			case 1:
+				goto exec;
+			case 2:
+				break;
+			}
+		fprintf(stderr, "\n");
+		fflush(stderr);
+	}
+exec:
+	switch (pid = fork()) {
+	case -1:
+		err(1, "fork");
+	case 0:
+		if (oflag) {
+			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1) {
+				warn("can't open /dev/tty");
+				_exit(1);
+			}
+		} else {
+			fd = open(_PATH_DEVNULL, O_RDONLY);
+		}
+		if (fd > STDIN_FILENO) {
+			if (dup2(fd, STDIN_FILENO) != 0) {
+				warn("can't dup2 to stdin");
+				_exit(1);
+			}
+			close(fd);
+		}
+		execvp(argv[0], argv);
+		warn("%s", argv[0]);
+		_exit(errno == ENOENT ? 127 : 126);
+	}
+	curprocs++;
+	waitchildren(*argv, 0);
+}
+
+static void
+waitchildren(const char *name, int waitall)
+{
+	pid_t pid;
+	int status;
+
+	while ((pid = waitpid(-1, &status, !waitall && curprocs < maxprocs ?
+	    WNOHANG : 0)) > 0) {
+		curprocs--;
+		/*
+		 * According to POSIX, we have to exit if the utility exits
+		 * with a 255 status, or is interrupted by a signal.
+		 * We are allowed to return any exit status between 1 and
+		 * 125 in these cases, but we'll use 124 and 125, the same
+		 * values used by GNU xargs.
+		 */
+		if (WIFEXITED(status)) {
+			if (WEXITSTATUS(status) == 255) {
+				warnx("%s exited with status 255", name);
+				exit(124);
+			} else if (WEXITSTATUS(status) == 127 ||
+			    WEXITSTATUS(status) == 126) {
+				exit(WEXITSTATUS(status));
+			} else if (WEXITSTATUS(status) != 0) {
+				rval = 123;
+			}
+		} else if (WIFSIGNALED(status)) {
+			if (WTERMSIG(status) != SIGPIPE) {
+				if (WTERMSIG(status) < NSIG) {
+					char signame[SIG2STR_MAX];
+					signame[0] = '\0';
+					sig2str(WTERMSIG(status), signame);
+					warnx("%s terminated by SIG%s", name,
+					    signame);
+				}
+			}
+			exit(125);
+		}
+	}
+	if (pid == -1 && errno != ECHILD)
+		err(1, "waitpid");
+}
+
+/*
+ * Prompt the user about running a command.
+ */
+static int
+prompt(void)
+{
+	size_t rsize = 0;
+	char *response = NULL;
+	FILE *ttyfp;
+	int doit = 0;
+
+	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
+		return (2);	/* Indicate that the TTY failed to open. */
+	fprintf(stderr, "?...");
+	fflush(stderr);
+	ssize_t nread = getline(&response, &rsize, ttyfp);
+	doit = nread != -1 && (*response == 'y' || *response == 'Y');
+	free(response);
+	fclose(ttyfp);
+	return (doit);
+}
+
+static void
+usage(void)
+{
+	fprintf(stderr,
+"usage: xargs [-0oprt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr]\n"
+"             [-L number] [-n number [-x]] [-P maxprocs] [-s size]\n"
+"             [utility [argument ...]]\n");
+	exit(1);
+}
